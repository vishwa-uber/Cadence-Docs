"use strict";(globalThis.webpackChunkcadence=globalThis.webpackChunkcadence||[]).push([[7895],{28453:(e,n,r)=>{r.d(n,{R:()=>c,x:()=>s});var t=r(96540);const i={},o=t.createContext(i);function c(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),t.createElement(o.Provider,{value:n},e.children)}},43241:e=>{e.exports=JSON.parse('{"permalink":"/Cadence-Docs/blog/2025/09/25/introducing-batch-future-faster-activity-execution","editUrl":"https://github.com/cadence-workflow/Cadence-Docs/tree/master/blog/2025-09-25-introducing-batch-future-faster-activity-execution.md","source":"@site/blog/2025-09-25-introducing-batch-future-faster-activity-execution.md","title":"Introducing Batch Future with Concurrency Control","description":"We\'re excited to announce Batch Future, a new feature in the Cadence Go client that provides controlled concurrency for bulk operations, preventing overwhelming downstream services while maintaining efficient parallel processing.","date":"2025-09-25T00:00:00.000Z","tags":[{"inline":false,"label":"Announcement","permalink":"/Cadence-Docs/blog/tags/announcements","description":"Announcement tag description"},{"inline":false,"label":"Releases","permalink":"/Cadence-Docs/blog/tags/releases","description":"Releases tag description"}],"readingTime":5.76,"hasTruncateMarker":true,"authors":[{"name":"Kevin Burns","title":"Developer Advocate @ Uber","url":"https://www.linkedin.com/in/kevin-burns-8182aa58/","page":{"permalink":"/Cadence-Docs/blog/authors/kevinb"},"socials":{"linkedin":"https://www.linkedin.com/in/kevin-burns-8182aa58/","github":"https://github.com/bueller87"},"imageURL":"https://github.com/bueller87.png","key":"kevinb"}],"frontMatter":{"title":"Introducing Batch Future with Concurrency Control","description":"We\'re excited to announce Batch Future, a new feature in the Cadence Go client that provides controlled concurrency for bulk operations, preventing overwhelming downstream services while maintaining efficient parallel processing.","date":"2025-09-25T00:00:00.000Z","authors":"kevinb","tags":["announcement","release"]},"unlisted":false,"prevItem":{"title":"Cadence Joins CNCF (Cloud Native Computing Foundation)","permalink":"/Cadence-Docs/blog/2025/10/06/cadence-joins-cncf-cloud-native-computing-foundation"},"nextItem":{"title":"Workflow Diagnostics","permalink":"/Cadence-Docs/blog/2025/08/06/workflow-diagnostics"}}')},90928:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>c,metadata:()=>t,toc:()=>a});var t=r(43241),i=r(74848),o=r(28453);const c={title:"Introducing Batch Future with Concurrency Control",description:"We're excited to announce Batch Future, a new feature in the Cadence Go client that provides controlled concurrency for bulk operations, preventing overwhelming downstream services while maintaining efficient parallel processing.",date:new Date("2025-09-25T00:00:00.000Z"),authors:"kevinb",tags:["announcement","release"]},s=void 0,l={authorsImageUrls:[void 0]},a=[{value:"The Problem: Uncontrolled Concurrency",id:"the-problem-uncontrolled-concurrency",level:2},{value:"The Solution: Batch Future",id:"the-solution-batch-future",level:2},{value:"Key Benefits: Controlled Concurrency",id:"key-benefits-controlled-concurrency",level:2},{value:"Real-World Use Cases",id:"real-world-use-cases",level:2},{value:"1. Multi-Service Data Synchronization",id:"1-multi-service-data-synchronization",level:3},{value:"2. Progressive Data Processing with Different Priorities",id:"2-progressive-data-processing-with-different-priorities",level:3},{value:"3. Conditional Batch Processing with Retry Logic",id:"3-conditional-batch-processing-with-retry-logic",level:3},{value:"How It Works Under the Hood",id:"how-it-works-under-the-hood",level:2},{value:"Getting Started",id:"getting-started",level:2},{value:"1. Update Your Go Client",id:"1-update-your-go-client",level:3},{value:"2. Try the Sample",id:"2-try-the-sample",level:3},{value:"3. Migrate Your Workflows (With Caution)",id:"3-migrate-your-workflows-with-caution",level:3},{value:"The Challenge",id:"the-challenge",level:4},{value:"Migration Approaches",id:"migration-approaches",level:4},{value:"Testing Strategy",id:"testing-strategy",level:4},{value:"Key Considerations",id:"key-considerations",level:4},{value:"When NOT to Migrate",id:"when-not-to-migrate",level:4},{value:"Best Practices",id:"best-practices",level:2},{value:"Try It Today!",id:"try-it-today",level:2}];function u(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Are you struggling with uncontrolled concurrency when trying to process thousands of activities or child workflows? Do you find yourself hitting rate limits or overwhelming downstream services when running bulk operations? We've got great news for you!"}),"\n",(0,i.jsxs)(n.p,{children:["Today, we're thrilled to announce ",(0,i.jsx)(n.strong,{children:"Batch Future"}),", a powerful new feature in the Cadence Go client that provides controlled concurrency for bulk operations. You can now process multiple activities in parallel while maintaining precise control over how many run simultaneously."]}),"\n",(0,i.jsx)(n.h2,{id:"the-problem-uncontrolled-concurrency",children:"The Problem: Uncontrolled Concurrency"}),"\n",(0,i.jsx)(n.p,{children:"Traditionally, when you need to process multiple items in a Cadence workflow, you'd write something like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"func ProcessUsers(ctx workflow.Context, userIDs []string) error {\n    var futures []workflow.Future\n    for _, userID := range userIDs {\n        future := workflow.ExecuteActivity(ctx, UpdateUserActivity, userID)\n        futures = append(futures, future)\n    }\n    \n    // Wait for all activities to complete\n    for _, future := range futures {\n        if err := future.Get(ctx, nil); err != nil {\n            return err\n        }\n    }\n    return nil\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This approach works, but it has ",(0,i.jsx)(n.strong,{children:"uncontrolled concurrency"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"All activities start simultaneously, potentially overwhelming downstream services"}),"\n",(0,i.jsx)(n.li,{children:"No way to limit concurrent executions"}),"\n",(0,i.jsx)(n.li,{children:"Difficult to manage resource usage"}),"\n",(0,i.jsx)(n.li,{children:"Can cause rate limiting or timeouts"}),"\n",(0,i.jsx)(n.li,{children:"Causing hot shard in Cadence server's task processing"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"the-solution-batch-future",children:"The Solution: Batch Future"}),"\n",(0,i.jsxs)(n.p,{children:["With Batch Future, you can process users with ",(0,i.jsx)(n.strong,{children:"controlled concurrency"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'func ProcessUsersBatch(ctx workflow.Context, userIDs []string, concurrency int) error {\n    // Create activity factories for each user\n    factories := make([]func(workflow.Context) workflow.Future, len(userIDs))\n    for i, userID := range userIDs {\n        userID := userID // Capture loop variable for closure\n        factories[i] = func(ctx workflow.Context) workflow.Future {\n            return workflow.ExecuteActivity(ctx, UpdateUserActivity, userID)\n        }\n    }\n    \n    // Execute with controlled concurrency\n    batch, err := workflow.NewBatchFuture(ctx, concurrency, factories)\n    if err != nil {\n        return fmt.Errorf("failed to create batch future: %w", err)\n    }\n    \n    // Wait for all activities to complete\n    return batch.Get(ctx, nil)\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"key-benefits-controlled-concurrency",children:"Key Benefits: Controlled Concurrency"}),"\n",(0,i.jsx)(n.p,{children:"Batch Future provides several important advantages:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Controlled Concurrency"}),": Limit simultaneous executions to prevent overwhelming downstream services"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Resource Management"}),": Better control over memory and CPU usage"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Rate Limiting Protection"}),": Avoid hitting API rate limits by controlling execution speed"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Graceful Cancellation"}),": All activities can be cancelled together if needed"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Simplified Error Handling"}),": Single point of failure handling for the entire batch"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"real-world-use-cases",children:"Real-World Use Cases"}),"\n",(0,i.jsx)(n.p,{children:"Batch Future is perfect for scenarios like:"}),"\n",(0,i.jsx)(n.h3,{id:"1-multi-service-data-synchronization",children:"1. Multi-Service Data Synchronization"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'func SyncProductData(ctx workflow.Context, products []Product) error {\n    // Sync to multiple services with different concurrency limits\n    inventoryBatch := createBatch(ctx, products, 5, SyncToInventoryActivity)\n    searchBatch := createBatch(ctx, products, 3, SyncToSearchActivity)\n    analyticsBatch := createBatch(ctx, products, 2, SyncToAnalyticsActivity)\n    \n    // Wait for all sync operations to complete\n    if err := inventoryBatch.Get(ctx, nil); err != nil {\n        return fmt.Errorf("inventory sync failed: %w", err)\n    }\n    if err := searchBatch.Get(ctx, nil); err != nil {\n        return fmt.Errorf("search sync failed: %w", err)\n    }\n    return analyticsBatch.Get(ctx, nil)\n}\n\nfunc createBatch(ctx workflow.Context, items []Product, concurrency int, activityFunc interface{}) workflow.Future {\n    factories := make([]func(workflow.Context) workflow.Future, len(items))\n    for i, item := range items {\n        item := item\n        factories[i] = func(ctx workflow.Context) workflow.Future {\n            return workflow.ExecuteActivity(ctx, activityFunc, item)\n        }\n    }\n    batch, _ := workflow.NewBatchFuture(ctx, concurrency, factories)\n    return batch\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"2-progressive-data-processing-with-different-priorities",children:"2. Progressive Data Processing with Different Priorities"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'func ProcessDataWithPriorities(ctx workflow.Context, data []DataItem) error {\n    // High priority items get more concurrency\n    highPriority := filterByPriority(data, "high")\n    lowPriority := filterByPriority(data, "low")\n    \n    // Process high priority items first with high concurrency\n    highBatch, _ := workflow.NewBatchFuture(ctx, 10, createFactories(highPriority, ProcessHighPriorityActivity))\n    \n    // Wait for high priority to complete, then process low priority with lower concurrency\n    if err := highBatch.Get(ctx, nil); err != nil {\n        return err\n    }\n    \n    lowBatch, _ := workflow.NewBatchFuture(ctx, 3, createFactories(lowPriority, ProcessLowPriorityActivity))\n    return lowBatch.Get(ctx, nil)\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"3-conditional-batch-processing-with-retry-logic",children:"3. Conditional Batch Processing with Retry Logic"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"func ProcessOrdersWithRetry(ctx workflow.Context, orders []Order) error {\n    // First attempt with normal concurrency\n    factories := make([]func(workflow.Context) workflow.Future, len(orders))\n    for i, order := range orders {\n        order := order\n        factories[i] = func(ctx workflow.Context) workflow.Future {\n            return workflow.ExecuteActivity(ctx, ProcessOrderActivity, order)\n        }\n    }\n    \n    batch, _ := workflow.NewBatchFuture(ctx, 5, factories)\n    if err := batch.Get(ctx, nil); err != nil {\n        // If batch fails, retry failed orders individually with higher concurrency\n        return retryFailedOrders(ctx, orders, 10)\n    }\n    return nil\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"how-it-works-under-the-hood",children:"How It Works Under the Hood"}),"\n",(0,i.jsx)(n.p,{children:"Batch Future leverages Cadence's existing activity infrastructure with controlled concurrency:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Future Factories"}),": Creates lazy-evaluated future creation functions that aren't scheduled until needed"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Concurrency Control"}),": Limits the number of pending futures"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Queue Management"}),": Maintains a queue of to-be-scheduled futures and starts new ones as others complete"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Future Management"}),": Returns a single future that completes when all futures finish"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Error Propagation"}),": If any future fails, the error is stored in a multi-error wrapper entity, users can either cancel or fail open"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"getting-started",children:"Getting Started"}),"\n",(0,i.jsx)(n.p,{children:"Ready to supercharge your workflows? Here's how to get started:"}),"\n",(0,i.jsx)(n.h3,{id:"1-update-your-go-client",children:"1. Update Your Go Client"}),"\n",(0,i.jsx)(n.p,{children:"Make sure you're using the latest version of the Cadence Go client:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"go get github.com/uber/cadence-go-client@latest\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-try-the-sample",children:"2. Try the Sample"}),"\n",(0,i.jsxs)(n.p,{children:["Check out our ",(0,i.jsx)(n.a,{href:"https://github.com/cadence-workflow/cadence-samples/tree/master/cmd/samples/batch",children:"Batch Future sample"})," to see it in action."]}),"\n",(0,i.jsx)(n.h3,{id:"3-migrate-your-workflows-with-caution",children:"3. Migrate Your Workflows (With Caution)"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"This is not a simple code change"}),". Migrating to Batch Future requires workflow versioning and careful production planning."]}),"\n",(0,i.jsx)(n.h4,{id:"the-challenge",children:"The Challenge"}),"\n",(0,i.jsx)(n.p,{children:"Batch Future changes your workflow's execution pattern from individual activities to controlled batching. This creates non-deterministic changes that will break existing running workflows without proper versioning."}),"\n",(0,i.jsx)(n.h4,{id:"migration-approaches",children:"Migration Approaches"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Option A: Versioned Migration (Recommended for Production)"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Use ",(0,i.jsx)(n.a,{href:"https://cadenceworkflow.io/docs/go-client/workflow-versioning",children:"workflow.GetVersion()"})," to support both old and new patterns"]}),"\n",(0,i.jsx)(n.li,{children:"Deploy code that handles both execution patterns"}),"\n",(0,i.jsx)(n.li,{children:"Gradually transition new workflows to use Batch Future"}),"\n",(0,i.jsx)(n.li,{children:"Clean up old code after all workflows complete"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Option B: New Workflow Type (Simpler but Requires Coordination)"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Create a new workflow type specifically for Batch Future"}),"\n",(0,i.jsx)(n.li,{children:"Update callers to use the new workflow type"}),"\n",(0,i.jsx)(n.li,{children:"Deprecate the old workflow type after migration"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Option C: Workflow Replacement (Not Gradual)"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Terminate existing workflows (if acceptable)"}),"\n",(0,i.jsx)(n.li,{children:"Deploy new code with Batch Future"}),"\n",(0,i.jsx)(n.li,{children:"Start new workflows with the new pattern"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"testing-strategy",children:"Testing Strategy"}),"\n",(0,i.jsxs)(n.p,{children:["Before deploying, use ",(0,i.jsx)(n.a,{href:"https://cadenceworkflow.io/docs/go-client/workflow-replay-shadowing",children:"Workflow Shadowing"})," to replay production workflow histories against your new code. This catches compatibility issues before they reach production."]}),"\n",(0,i.jsx)(n.h4,{id:"key-considerations",children:"Key Considerations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Timeline"}),": Plan for weeks, not days"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Coordination"}),": Requires careful coordination between teams"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Monitoring"}),": Essential during transition period"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Rollback"}),": Always have a rollback plan ready"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Testing"}),": Extensive testing in staging environment required"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"when-not-to-migrate",children:"When NOT to Migrate"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"If you have long-running workflows (weeks/months)"}),"\n",(0,i.jsx)(n.li,{children:"If you can't coordinate a proper versioning strategy"}),"\n",(0,i.jsx)(n.li,{children:"If the performance benefits don't justify the migration complexity"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Choose Appropriate Concurrency"}),": Start with 3-5 concurrent activities and adjust based on downstream service capacity"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Activity Factories"}),": Always capture loop variables in closures to avoid race conditions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Error Handling"}),": Implement proper error handling for individual activity failures"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Resource Management"}),": Consider memory usage for large batches"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Monitoring"}),": Use heartbeats for long-running activities within the batch"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"try-it-today",children:"Try It Today!"}),"\n",(0,i.jsx)(n.p,{children:"Batch Future is available now in the latest Cadence Go client. We can't wait to see how you use it to optimize your workflows!"}),"\n",(0,i.jsxs)(n.p,{children:["Have questions or feedback? Join our ",(0,i.jsx)(n.a,{href:"http://t.uber.com/cadence-slack",children:"Slack community"})," or open an issue on ",(0,i.jsx)(n.a,{href:"https://github.com/cadence-workflow/cadence-go-client",children:"GitHub"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Happy coding, and here's to faster, more efficient workflows!"})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}}}]);