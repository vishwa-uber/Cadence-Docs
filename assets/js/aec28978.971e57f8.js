"use strict";(self.webpackChunkcadence=self.webpackChunkcadence||[]).push([[9757],{52926:(e,o,t)=>{t.r(o),t.d(o,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>c,metadata:()=>n,toc:()=>a});const n=JSON.parse('{"id":"go-client/workflow-versioning","title":"Versioning","description":"The definition code of a Cadence must be deterministic because Cadence uses sourcing","source":"@site/docs/05-go-client/15-workflow-versioning.md","sourceDirName":"05-go-client","slug":"/go-client/workflow-versioning","permalink":"/Cadence-Docs/docs/go-client/workflow-versioning","draft":false,"unlisted":false,"editUrl":"https://github.com/cadence-workflow/Cadence-Docs/tree/master/docs/05-go-client/15-workflow-versioning.md","tags":[],"version":"current","lastUpdatedBy":"Seva Kaloshin","lastUpdatedAt":1751974713000,"sidebarPosition":15,"frontMatter":{"layout":"default","title":"Versioning","permalink":"/docs/go-client/workflow-versioning"},"sidebar":"docsSidebar","previous":{"title":"Testing","permalink":"/Cadence-Docs/docs/go-client/workflow-testing"},"next":{"title":"Sessions","permalink":"/Cadence-Docs/docs/go-client/sessions"}}');var i=t(74848),r=t(28453);const c={layout:"default",title:"Versioning",permalink:"/docs/go-client/workflow-versioning"},s="Versioning",l={},a=[{value:"workflow.GetVersion()",id:"workflowgetversion",level:2},{value:"Safe Deployment of Versioned Workflows",id:"safe-deployment-of-versioned-workflows",level:2},{value:"Step 1: Deploy with Compatibility",id:"step-1-deploy-with-compatibility",level:3},{value:"Step 2: Activate New Logic",id:"step-2-activate-new-logic",level:3},{value:"Step 3: Clean Up Old Code",id:"step-3-clean-up-old-code",level:3},{value:"Sanity checking",id:"sanity-checking",level:2}];function d(e){const o={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(o.header,{children:(0,i.jsx)(o.h1,{id:"versioning",children:"Versioning"})}),"\n",(0,i.jsx)(o.p,{children:"The definition code of a Cadence workflow must be deterministic because Cadence uses event sourcing\nto reconstruct the workflow state by replaying the saved history event data on the workflow\ndefinition code. This means that any incompatible update to the workflow definition code could cause\na non-deterministic issue if not handled correctly."}),"\n",(0,i.jsx)(o.h2,{id:"workflowgetversion",children:"workflow.GetVersion()"}),"\n",(0,i.jsx)(o.p,{children:"Consider the following workflow definition:"}),"\n",(0,i.jsx)(o.pre,{children:(0,i.jsx)(o.code,{className:"language-go",children:'func MyWorkflow(ctx workflow.Context, data string) (string, error) {\n    ao := workflow.ActivityOptions{\n        ScheduleToStartTimeout: time.Minute,\n        StartToCloseTimeout:    time.Minute,\n    }\n    ctx = workflow.WithActivityOptions(ctx, ao)\n    var result1 string\n    err := workflow.ExecuteActivity(ctx, ActivityA, data).Get(ctx, &result1)\n    if err != nil {\n        return "", err\n    }\n    var result2 string\n    err = workflow.ExecuteActivity(ctx, ActivityB, result1).Get(ctx, &result2)\n    return result2, err\n}\n'})}),"\n",(0,i.jsx)(o.p,{children:"Now let's say we have replaced ActivityA with ActivityC, and deployed the updated code. If there\nis an existing workflow_execution that was started by the original version of the workflow code, where\nActivityA had already completed and the result was recorded to history, the new version of the workflow\ncode will pick up that workflow_execution and try to resume from there. However, the workflow will fail\nbecause the new code expects a result for ActivityC from the history data, but instead it gets the\nresult for ActivityA. This causes the workflow to fail on the non-deterministic error."}),"\n",(0,i.jsxs)(o.p,{children:["Thus we use ",(0,i.jsx)(o.code,{children:"workflow.GetVersion()."})]}),"\n",(0,i.jsx)(o.pre,{children:(0,i.jsx)(o.code,{className:"language-go",children:'var err error\nv := workflow.GetVersion(ctx, "Step1", workflow.DefaultVersion, 1)\nif v == workflow.DefaultVersion {\n    err = workflow.ExecuteActivity(ctx, ActivityA, data).Get(ctx, &result1)\n} else {\n    err = workflow.ExecuteActivity(ctx, ActivityC, data).Get(ctx, &result1)\n}\nif err != nil {\n    return "", err\n}\n\nvar result2 string\nerr = workflow.ExecuteActivity(ctx, ActivityB, result1).Get(ctx, &result2)\nreturn result2, err\n'})}),"\n",(0,i.jsxs)(o.p,{children:["When ",(0,i.jsx)(o.code,{children:"workflow.GetVersion()"})," is run for the new workflow_execution, it records a marker in the workflow\nhistory so that all future calls to ",(0,i.jsx)(o.code,{children:"GetVersion"})," for this change ID--",(0,i.jsx)(o.code,{children:"Step 1"})," in the example--on this\nworkflow_execution will always return the given version number, which is ",(0,i.jsx)(o.code,{children:"1"})," in the example."]}),"\n",(0,i.jsx)(o.p,{children:"If you make an additional change, such as replacing ActivityC with ActivityD, you need to\nadd some additional code:"}),"\n",(0,i.jsx)(o.pre,{children:(0,i.jsx)(o.code,{className:"language-go",children:'v := workflow.GetVersion(ctx, "Step1", workflow.DefaultVersion, 2)\nif v == workflow.DefaultVersion {\n    err = workflow.ExecuteActivity(ctx, ActivityA, data).Get(ctx, &result1)\n} else if v == 1 {\n    err = workflow.ExecuteActivity(ctx, ActivityC, data).Get(ctx, &result1)\n} else {\n    err = workflow.ExecuteActivity(ctx, ActivityD, data).Get(ctx, &result1)\n}\n'})}),"\n",(0,i.jsxs)(o.p,{children:["Note that we have changed ",(0,i.jsx)(o.code,{children:"maxSupported"})," from 1 to 2. A workflow that had already passed this\n",(0,i.jsx)(o.code,{children:"GetVersion()"})," call before it was introduced will return ",(0,i.jsx)(o.code,{children:"DefaultVersion"}),". A workflow that was run\nwith ",(0,i.jsx)(o.code,{children:"maxSupported"})," set to 1, will return 1. New workflows will return 2."]}),"\n",(0,i.jsx)(o.p,{children:"After you are sure that all of the workflow_executions prior to version 1 have completed, you can\nremove the code for that version. It should now look like the following:"}),"\n",(0,i.jsx)(o.pre,{children:(0,i.jsx)(o.code,{className:"language-go",children:'v := workflow.GetVersion(ctx, "Step1", 1, 2)\nif v == 1 {\n    err = workflow.ExecuteActivity(ctx, ActivityC, data).Get(ctx, &result1)\n} else {\n    err = workflow.ExecuteActivity(ctx, ActivityD, data).Get(ctx, &result1)\n}\n'})}),"\n",(0,i.jsxs)(o.p,{children:["You'll note that ",(0,i.jsx)(o.code,{children:"minSupported"})," has changed from ",(0,i.jsx)(o.code,{children:"DefaultVersion"})," to ",(0,i.jsx)(o.code,{children:"1"}),". If an older version of the\nworkflow_execution history is replayed on this code, it will fail because the minimum expected version\nis 1. After you are sure that all of the workflow_executions for version 1 have completed, then you\ncan remove 1 so that your code would look like the following:"]}),"\n",(0,i.jsx)(o.pre,{children:(0,i.jsx)(o.code,{className:"language-go",children:'_ := workflow.GetVersion(ctx, "Step1", 2, 2)\nerr = workflow.ExecuteActivity(ctx, ActivityD, data).Get(ctx, &result1)\n'})}),"\n",(0,i.jsxs)(o.p,{children:["Note that we have preserved the call to ",(0,i.jsx)(o.code,{children:"GetVersion()"}),". There are two reasons to preserve this call:"]}),"\n",(0,i.jsxs)(o.ol,{children:["\n",(0,i.jsx)(o.li,{children:"This ensures that if there is a workflow_execution still running for an older version, it will\nfail here and not proceed."}),"\n",(0,i.jsxs)(o.li,{children:["If you need to make additional changes for ",(0,i.jsx)(o.code,{children:"Step1"}),", such as changing ActivityD to ActivityE, you\nonly need to update ",(0,i.jsx)(o.code,{children:"maxVersion"})," from 2 to 3 and branch from there."]}),"\n"]}),"\n",(0,i.jsxs)(o.p,{children:["You only need to preserve the first call to ",(0,i.jsx)(o.code,{children:"GetVersion()"})," for each ",(0,i.jsx)(o.code,{children:"changeID"}),". All subsequent calls to\n",(0,i.jsx)(o.code,{children:"GetVersion()"})," with the same change ID are safe to remove. If necessary, you can remove the first\n",(0,i.jsx)(o.code,{children:"GetVersion()"})," call, but you need to ensure the following:"]}),"\n",(0,i.jsxs)(o.ul,{children:["\n",(0,i.jsx)(o.li,{children:"All executions with an older version are completed."}),"\n",(0,i.jsxs)(o.li,{children:["You can no longer use ",(0,i.jsx)(o.code,{children:"Step1"})," for the changeID. If you need to make changes to that same part in\nthe future, such as change from ActivityD to ActivityE, you would need to use a different changeID\nlike ",(0,i.jsx)(o.code,{children:"Step1-fix2"}),", and start minVersion from DefaultVersion again. The code would look like the\nfollowing:"]}),"\n"]}),"\n",(0,i.jsx)(o.pre,{children:(0,i.jsx)(o.code,{className:"language-go",children:'v := workflow.GetVersion(ctx, "Step1-fix2", workflow.DefaultVersion, 1)\nif v == workflow.DefaultVersion {\n    err = workflow.ExecuteActivity(ctx, ActivityD, data).Get(ctx, &result1)\n} else {\n    err = workflow.ExecuteActivity(ctx, ActivityE, data).Get(ctx, &result1)\n}\n'})}),"\n",(0,i.jsxs)(o.p,{children:["Upgrading a workflow is straightforward if you don't need to preserve your currently running\nworkflow_executions. You can simply terminate all of the currently running workflow_executions and\nsuspend new ones from being created while you deploy the new version of your workflow code, which does\nnot use ",(0,i.jsx)(o.code,{children:"GetVersion()"}),", and then resume workflow creation. However, that is often not the case, and\nyou need to take care of the currently running workflow_executions, so using ",(0,i.jsx)(o.code,{children:"GetVersion()"})," to update\nyour code is the method to use."]}),"\n",(0,i.jsxs)(o.p,{children:["However, if you want your currently running workflows to proceed based on the current workflow logic,\nbut you want to ensure new workflows are running on new logic, you can define your workflow as a\nnew ",(0,i.jsx)(o.code,{children:"WorkflowType"}),", and change your start path (calls to ",(0,i.jsx)(o.code,{children:"StartWorkflow()"}),") to start the new workflow\ntype."]}),"\n",(0,i.jsx)(o.h2,{id:"safe-deployment-of-versioned-workflows",children:"Safe Deployment of Versioned Workflows"}),"\n",(0,i.jsxs)(o.p,{children:["When deploying workflow changes in production environments, you may want to separate the versioning\nof the workflow code from the activation of new logic to ensure ability to roll back changes safely.\nThe ",(0,i.jsx)(o.code,{children:"ExecuteWithVersion"}),"  and ",(0,i.jsx)(o.code,{children:"ExecuteWithMinVersion"})," options provides this capability by allowing you\nto control which version is returned when ",(0,i.jsx)(o.code,{children:"GetVersion()"})," is executed for the first time."]}),"\n",(0,i.jsx)(o.h3,{id:"step-1-deploy-with-compatibility",children:"Step 1: Deploy with Compatibility"}),"\n",(0,i.jsx)(o.p,{children:"Initially, your workflow has the following code:"}),"\n",(0,i.jsx)(o.pre,{children:(0,i.jsx)(o.code,{className:"language-go",children:"err = workflow.ExecuteActivity(ctx, FooActivity).Get(ctx, nil)\n"})}),"\n",(0,i.jsxs)(o.p,{children:["To safely roll out changes that replace ",(0,i.jsx)(o.code,{children:"FooActivity"})," with ",(0,i.jsx)(o.code,{children:"BarActivity"}),", you need both versions\nof your workflow code to be compatible with each other. Use ",(0,i.jsx)(o.code,{children:"GetVersion"})," with the ",(0,i.jsx)(o.code,{children:"ExecuteWithMinVersion"})," option:"]}),"\n",(0,i.jsx)(o.pre,{children:(0,i.jsx)(o.code,{className:"language-go",children:'v := workflow.GetVersion(ctx, "fooToBarChange", workflow.DefaultVersion, 1, workflow.ExecuteWithMinVersion())\n// equivalent to\n// v := workflow.GetVersion(ctx, "fooToBarChange", workflow.DefaultVersion, 1, workflow.ExecuteWithVersion(workflow.DefaultVersion))\nif v == workflow.DefaultVersion {\n    err = workflow.ExecuteActivity(ctx, FooActivity).Get(ctx, nil)\n} else {\n    err = workflow.ExecuteActivity(ctx, BarActivity).Get(ctx, nil)\n}\n'})}),"\n",(0,i.jsx)(o.p,{children:"At this step:"}),"\n",(0,i.jsxs)(o.ul,{children:["\n",(0,i.jsxs)(o.li,{children:["The previous version of the code supports only ",(0,i.jsx)(o.code,{children:"DefaultVersion"})]}),"\n",(0,i.jsxs)(o.li,{children:["The new version of the code supports both ",(0,i.jsx)(o.code,{children:"DefaultVersion"})," and ",(0,i.jsx)(o.code,{children:"1"})]}),"\n",(0,i.jsxs)(o.li,{children:["The new version of the code is not yet activated, so workflows started on the new code will still execute the ",(0,i.jsx)(o.code,{children:"FooActivity"})," (previous version)"]}),"\n",(0,i.jsxs)(o.li,{children:["This makes it possible to safely roll back your changes if needed, as the previous code supports ",(0,i.jsx)(o.code,{children:"DefaultVersion"})," only"]}),"\n"]}),"\n",(0,i.jsx)(o.h3,{id:"step-2-activate-new-logic",children:"Step 2: Activate New Logic"}),"\n",(0,i.jsxs)(o.p,{children:["When the previous version of the code is no longer running, you can activate the new code by removing the ",(0,i.jsx)(o.code,{children:"ExecuteWithMinVersion"})," option:"]}),"\n",(0,i.jsx)(o.pre,{children:(0,i.jsx)(o.code,{className:"language-go",children:'v := workflow.GetVersion(ctx, "fooToBarChange", workflow.DefaultVersion, 1)\nif v == workflow.DefaultVersion {\n    err = workflow.ExecuteActivity(ctx, FooActivity).Get(ctx, nil)\n} else {\n    err = workflow.ExecuteActivity(ctx, BarActivity).Get(ctx, nil)\n}\n'})}),"\n",(0,i.jsx)(o.p,{children:"At this step:"}),"\n",(0,i.jsxs)(o.ul,{children:["\n",(0,i.jsxs)(o.li,{children:["Both versions of the code support both ",(0,i.jsx)(o.code,{children:"DefaultVersion"})," and ",(0,i.jsx)(o.code,{children:"1"})]}),"\n",(0,i.jsxs)(o.li,{children:["The new version of the code is activated, so workflows started on the new code will execute the ",(0,i.jsx)(o.code,{children:"BarActivity"})," (new version)"]}),"\n",(0,i.jsxs)(o.li,{children:["This still allows safe rollback because both versions of the code support both ",(0,i.jsx)(o.code,{children:"DefaultVersion"})," and ",(0,i.jsx)(o.code,{children:"1"})]}),"\n"]}),"\n",(0,i.jsx)(o.h3,{id:"step-3-clean-up-old-code",children:"Step 3: Clean Up Old Code"}),"\n",(0,i.jsxs)(o.p,{children:["When there are no running workflows using ",(0,i.jsx)(o.code,{children:"DefaultVersion"}),", you can remove the corresponding branch:"]}),"\n",(0,i.jsx)(o.pre,{children:(0,i.jsx)(o.code,{className:"language-go",children:'workflow.GetVersion(ctx, "fooToBarChange", 1, 1)\nerr = workflow.ExecuteActivity(ctx, BarActivity).Get(ctx, nil)\n'})}),"\n",(0,i.jsxs)(o.p,{children:[(0,i.jsx)(o.code,{children:"ExecuteWithMinVersion"})," and ",(0,i.jsx)(o.code,{children:"ExecuteWithVersion"})," options are particularly useful when you want to ensure that\nyour changes can be safely rolled back if needed, as both versions of the workflow code remain compatible with\neach other throughout the deployment process."]}),"\n",(0,i.jsx)(o.h2,{id:"sanity-checking",children:"Sanity checking"}),"\n",(0,i.jsx)(o.p,{children:"The Cadence client SDK performs a sanity check to help prevent obvious incompatible changes.\nThe sanity check verifies whether a decision made in replay matches the event recorded in history,\nin the same order. The decision is generated by calling any of the following methods:"}),"\n",(0,i.jsxs)(o.ul,{children:["\n",(0,i.jsx)(o.li,{children:"workflow.ExecuteActivity()"}),"\n",(0,i.jsx)(o.li,{children:"workflow.ExecuteChildWorkflow()"}),"\n",(0,i.jsx)(o.li,{children:"workflow.NewTimer()"}),"\n",(0,i.jsx)(o.li,{children:"workflow.Sleep()"}),"\n",(0,i.jsx)(o.li,{children:"workflow.SideEffect()"}),"\n",(0,i.jsx)(o.li,{children:"workflow.RequestCancelWorkflow()"}),"\n",(0,i.jsx)(o.li,{children:"workflow.SignalExternalWorkflow()"}),"\n",(0,i.jsx)(o.li,{children:"workflow.UpsertSearchAttributes()"}),"\n"]}),"\n",(0,i.jsx)(o.p,{children:"Adding, removing, or reordering any of the above methods triggers the sanity check and results in\na non-deterministic error."}),"\n",(0,i.jsxs)(o.p,{children:["The sanity check does not perform a thorough check. For example, it does not check on the activity's\ninput arguments or the timer duration. If the check is enforced on every property, then it becomes\ntoo restricted and harder to maintain the workflow code. For example, if you move your activity code\nfrom one package to another package, that changes the ",(0,i.jsx)(o.code,{children:"ActivityType"}),", which technically becomes a different\nactivity. But, we don't want to fail on that change, so we only check the function name part of the\n",(0,i.jsx)(o.code,{children:"ActivityType"}),"."]})]})}function h(e={}){const{wrapper:o}={...(0,r.R)(),...e.components};return o?(0,i.jsx)(o,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,o,t)=>{t.d(o,{R:()=>c,x:()=>s});var n=t(96540);const i={},r=n.createContext(i);function c(e){const o=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function s(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),n.createElement(r.Provider,{value:o},e.children)}}}]);