"use strict";(self.webpackChunkcadence=self.webpackChunkcadence||[]).push([[4808],{85988:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"concepts/data-converter","title":"Data Converter","description":"Data Converters in Cadence handle serialization and deserialization of data exchanged between workflows, activities, and the Cadence service. They ensure data is correctly encoded and decoded during communication.","source":"@site/docs/03-concepts/11-data-converter.md","sourceDirName":"03-concepts","slug":"/concepts/data-converter","permalink":"/Cadence-Docs/docs/concepts/data-converter","draft":false,"unlisted":false,"editUrl":"https://github.com/cadence-workflow/Cadence-Docs/tree/master/docs/03-concepts/11-data-converter.md","tags":[],"version":"current","lastUpdatedBy":"Vishwa Patil","lastUpdatedAt":1754951687000,"sidebarPosition":11,"frontMatter":{"layout":"default","title":"Data Converter","permalink":"/docs/concepts/data-converter"},"sidebar":"docsSidebar","previous":{"title":"HTTP API","permalink":"/Cadence-Docs/docs/concepts/http-api"},"next":{"title":"Workflow Queries with Formatted Data","permalink":"/Cadence-Docs/docs/concepts/workflow-queries-formatted-data"}}');var a=r(74848),o=r(28453);const i={layout:"default",title:"Data Converter",permalink:"/docs/concepts/data-converter"},s="Data Converter",c={},l=[{value:"Key Features",id:"key-features",level:2},{value:"Custom Serialization",id:"custom-serialization",level:3},{value:"Data Compression",id:"data-compression",level:3},{value:"Encryption",id:"encryption",level:3},{value:"Format Support",id:"format-support",level:3},{value:"Default Data Converter",id:"default-data-converter",level:2},{value:"Custom Data Converter Implementation",id:"custom-data-converter-implementation",level:2},{value:"Encryption Data Converter",id:"encryption-data-converter",level:2},{value:"Using Custom Data Converters",id:"using-custom-data-converters",level:2},{value:"Protocol Buffers Data Converter",id:"protocol-buffers-data-converter",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Performance Considerations",id:"performance-considerations",level:3},{value:"Security",id:"security",level:3},{value:"Compatibility",id:"compatibility",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"References",id:"references",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"data-converter",children:"Data Converter"})}),"\n",(0,a.jsx)(n.p,{children:"Data Converters in Cadence handle serialization and deserialization of data exchanged between workflows, activities, and the Cadence service. They ensure data is correctly encoded and decoded during communication."}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"key-features",children:"Key Features"}),"\n",(0,a.jsx)(n.h3,{id:"custom-serialization",children:"Custom Serialization"}),"\n",(0,a.jsx)(n.p,{children:"Implement custom serialization logic for complex data types that require special handling beyond the default JSON encoding."}),"\n",(0,a.jsx)(n.h3,{id:"data-compression",children:"Data Compression"}),"\n",(0,a.jsx)(n.p,{children:"Reduce payload size for efficient data transfer, especially important for large data objects or high-throughput workflows."}),"\n",(0,a.jsx)(n.h3,{id:"encryption",children:"Encryption"}),"\n",(0,a.jsx)(n.p,{children:"Secure sensitive data during transmission and storage by implementing encryption/decryption in your custom data converter."}),"\n",(0,a.jsx)(n.h3,{id:"format-support",children:"Format Support"}),"\n",(0,a.jsx)(n.p,{children:"Support various serialization formats like JSON, Protocol Buffers, MessagePack, or custom binary formats."}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"default-data-converter",children:"Default Data Converter"}),"\n",(0,a.jsx)(n.p,{children:"Cadence provides a default data converter that uses JSON for serialization. It handles most common Go types automatically and is suitable for most use cases."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:'import (\n    "go.uber.org/cadence/client"\n    "go.uber.org/cadence/encoded"\n)\n\n// The default data converter is used automatically\n// when creating a workflow client\nworkflowClient := client.NewClient(\n    cadenceClient,\n    domain,\n    &client.Options{},\n)\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"custom-data-converter-implementation",children:"Custom Data Converter Implementation"}),"\n",(0,a.jsxs)(n.p,{children:["You can implement a custom data converter by implementing the ",(0,a.jsx)(n.code,{children:"encoded.DataConverter"})," interface. Here's an example of a custom data converter that adds compression:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "bytes"\n    "compress/gzip"\n    "encoding/json"\n    "fmt"\n    "io"\n\n    "go.uber.org/cadence/encoded"\n)\n\n// CompressionDataConverter wraps the default JSON data converter\n// with gzip compression for payload size optimization\ntype CompressionDataConverter struct {\n    encoded.DataConverter\n}\n\n// NewCompressionDataConverter creates a new compression data converter\nfunc NewCompressionDataConverter() *CompressionDataConverter {\n    return &CompressionDataConverter{\n        DataConverter: encoded.GetDefaultDataConverter(),\n    }\n}\n\n// ToData converts a value to compressed encoded data\nfunc (dc *CompressionDataConverter) ToData(values ...interface{}) ([]byte, error) {\n    // First, serialize using the default JSON converter\n    data, err := dc.DataConverter.ToData(values...)\n    if err != nil {\n        return nil, err\n    }\n\n    // Compress the serialized data\n    var buf bytes.Buffer\n    gzWriter := gzip.NewWriter(&buf)\n    \n    if _, err := gzWriter.Write(data); err != nil {\n        return nil, fmt.Errorf("failed to compress data: %w", err)\n    }\n    \n    if err := gzWriter.Close(); err != nil {\n        return nil, fmt.Errorf("failed to close gzip writer: %w", err)\n    }\n\n    return buf.Bytes(), nil\n}\n\n// FromData converts compressed encoded data back to values\nfunc (dc *CompressionDataConverter) FromData(data []byte, values ...interface{}) error {\n    // Decompress the data\n    gzReader, err := gzip.NewReader(bytes.NewReader(data))\n    if err != nil {\n        return fmt.Errorf("failed to create gzip reader: %w", err)\n    }\n    defer gzReader.Close()\n\n    decompressedData, err := io.ReadAll(gzReader)\n    if err != nil {\n        return fmt.Errorf("failed to decompress data: %w", err)\n    }\n\n    // Deserialize using the default JSON converter\n    return dc.DataConverter.FromData(decompressedData, values...)\n}\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"encryption-data-converter",children:"Encryption Data Converter"}),"\n",(0,a.jsx)(n.p,{children:"For sensitive data, you can implement an encryption data converter:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "crypto/aes"\n    "crypto/cipher"\n    "crypto/rand"\n    "errors"\n    "io"\n\n    "go.uber.org/cadence/encoded"\n)\n\n// EncryptionDataConverter adds AES encryption to data serialization\ntype EncryptionDataConverter struct {\n    encoded.DataConverter\n    key []byte\n}\n\n// NewEncryptionDataConverter creates a new encryption data converter\nfunc NewEncryptionDataConverter(key []byte) *EncryptionDataConverter {\n    return &EncryptionDataConverter{\n        DataConverter: encoded.GetDefaultDataConverter(),\n        key:          key,\n    }\n}\n\n// ToData encrypts the serialized data\nfunc (dc *EncryptionDataConverter) ToData(values ...interface{}) ([]byte, error) {\n    // Serialize first\n    data, err := dc.DataConverter.ToData(values...)\n    if err != nil {\n        return nil, err\n    }\n\n    // Encrypt the data\n    block, err := aes.NewCipher(dc.key)\n    if err != nil {\n        return nil, err\n    }\n\n    // Generate a random nonce\n    nonce := make([]byte, 12) // GCM standard nonce size\n    if _, err := io.ReadFull(rand.Reader, nonce); err != nil {\n        return nil, err\n    }\n\n    aesgcm, err := cipher.NewGCM(block)\n    if err != nil {\n        return nil, err\n    }\n\n    ciphertext := aesgcm.Seal(nonce, nonce, data, nil)\n    return ciphertext, nil\n}\n\n// FromData decrypts and deserializes the data\nfunc (dc *EncryptionDataConverter) FromData(data []byte, values ...interface{}) error {\n    if len(data) < 12 {\n        return errors.New("ciphertext too short")\n    }\n\n    block, err := aes.NewCipher(dc.key)\n    if err != nil {\n        return err\n    }\n\n    aesgcm, err := cipher.NewGCM(block)\n    if err != nil {\n        return err\n    }\n\n    // Extract nonce and ciphertext\n    nonce, ciphertext := data[:12], data[12:]\n\n    // Decrypt\n    plaintext, err := aesgcm.Open(nil, nonce, ciphertext, nil)\n    if err != nil {\n        return err\n    }\n\n    // Deserialize\n    return dc.DataConverter.FromData(plaintext, values...)\n}\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"using-custom-data-converters",children:"Using Custom Data Converters"}),"\n",(0,a.jsx)(n.p,{children:"To use a custom data converter with your Cadence client:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "go.uber.org/cadence/client"\n    "go.uber.org/cadence/worker"\n)\n\nfunc main() {\n    // Create custom data converter\n    customDataConverter := NewCompressionDataConverter()\n    \n    // Use with workflow client\n    workflowClient := client.NewClient(\n        cadenceClient,\n        domain,\n        &client.Options{\n            DataConverter: customDataConverter,\n        },\n    )\n\n    // Use with worker\n    worker := worker.New(\n        cadenceClient,\n        domain,\n        taskList,\n        worker.Options{\n            DataConverter: customDataConverter,\n        },\n    )\n}\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"protocol-buffers-data-converter",children:"Protocol Buffers Data Converter"}),"\n",(0,a.jsx)(n.p,{children:"For high-performance applications, you might want to use Protocol Buffers:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "fmt"\n    "reflect"\n\n    "google.golang.org/protobuf/proto"\n    "go.uber.org/cadence/encoded"\n)\n\n// ProtoDataConverter handles Protocol Buffers serialization\ntype ProtoDataConverter struct{}\n\n// NewProtoDataConverter creates a new Protocol Buffers data converter\nfunc NewProtoDataConverter() *ProtoDataConverter {\n    return &ProtoDataConverter{}\n}\n\n// ToData serializes proto messages to bytes\nfunc (dc *ProtoDataConverter) ToData(values ...interface{}) ([]byte, error) {\n    if len(values) != 1 {\n        return nil, fmt.Errorf("proto data converter expects exactly one value")\n    }\n\n    message, ok := values[0].(proto.Message)\n    if !ok {\n        return nil, fmt.Errorf("value must implement proto.Message interface")\n    }\n\n    return proto.Marshal(message)\n}\n\n// FromData deserializes bytes to proto messages\nfunc (dc *ProtoDataConverter) FromData(data []byte, values ...interface{}) error {\n    if len(values) != 1 {\n        return fmt.Errorf("proto data converter expects exactly one value")\n    }\n\n    // Get the pointer to the value\n    rv := reflect.ValueOf(values[0])\n    if rv.Kind() != reflect.Ptr {\n        return fmt.Errorf("value must be a pointer")\n    }\n\n    message, ok := values[0].(proto.Message)\n    if !ok {\n        return fmt.Errorf("value must implement proto.Message interface")\n    }\n\n    return proto.Unmarshal(data, message)\n}\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(n.h3,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Use compression for large payloads to reduce network overhead"}),"\n",(0,a.jsx)(n.li,{children:"Consider binary formats like Protocol Buffers for high-throughput scenarios"}),"\n",(0,a.jsx)(n.li,{children:"Profile your data converter implementation for performance bottlenecks"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"security",children:"Security"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Always encrypt sensitive data before serialization"}),"\n",(0,a.jsx)(n.li,{children:"Use strong encryption algorithms and proper key management"}),"\n",(0,a.jsx)(n.li,{children:"Consider rotating encryption keys periodically"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"compatibility",children:"Compatibility"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Ensure backward compatibility when updating data converter implementations"}),"\n",(0,a.jsx)(n.li,{children:"Test data converter changes thoroughly before deploying to production"}),"\n",(0,a.jsx)(n.li,{children:"Document any breaking changes in serialization format"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Implement robust error handling in custom data converters"}),"\n",(0,a.jsx)(n.li,{children:"Provide meaningful error messages for debugging"}),"\n",(0,a.jsx)(n.li,{children:"Consider fallback mechanisms for corrupted or incompatible data"}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,a.jsx)(n.p,{children:"For complete working examples and advanced implementations, refer to the official Cadence samples:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://github.com/cadence-workflow/cadence-samples/tree/master/cmd/samples/recipes/dataconverter",children:"Data Converter Recipe"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://pkg.go.dev/go.uber.org/cadence",children:"Cadence Go Client Documentation"})}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(n.p,{children:"Data Converters are a powerful feature in Cadence that allow developers to customize how data is handled during workflow execution. By leveraging custom converters, you can optimize performance, ensure data security, and support various serialization formats. The examples provided demonstrate compression, encryption, and Protocol Buffers implementations that can be adapted to your specific use cases."})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>s});var t=r(96540);const a={},o=t.createContext(a);function i(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);